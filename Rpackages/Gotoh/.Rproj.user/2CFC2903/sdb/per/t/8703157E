{
    "contents" : "/**\n * @file\n * @author  Rafael Nozal Cañadas <rafaelc@cbu.uib.no>\n * @version 0.1\n *\n * @section LICENSE\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of\n * the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details at\n * http://www.gnu.org/copyleft/gpl.html\n *\n * @section DESCRIPTION\n *\n * \tRcpp script for aligning several sequences with a single subject                \n *\tsequence, one by one.\n *\n *\tThe script allocate memory for one matrix only. After an alignment,\n *\tthe subject sequence remain in place an a new sequence is given.\n *\n *  The results are given in a string witht the following format:\n *\n *\tSUBJECT SEQUENCE@SEQUENCE 1 \n *\tIndels:\n *\tStart@End@<Pattern,Subject>\n *\tMismatches:\n *\tPossition@Subject Base@Pattern Base\n *\tSUBJECT SEQUENCE@SEQUENCE 2\n *\t...\n *\n *\tThe class Alignment_Result is also implemented.\n *\n *  Compiled and builded with:\n *  g++ -std=c++11 -Wall -c \"%f\"\n *  g++ -std=c++11 -Wall -o \"%e\" \"%f\"\n */\n\n/** @todo : Spelling! */\n\n#include <iostream>\n#include <string>\n#include <stdlib.h>\n#include <stdio.h>\n#include <cstdlib>\n#include <list> \n#include <algorithm> //reverse() when reverse the traceback result\n#include <limits>    // in limits<int>:min()\n#include <typeinfo>  //in printMatrix<T>, string or int\n#include <ctype.h>   // characters to uppercase\n\n//#include <Rcpp.h>  //If you are not working with R, comment this line\n\t\t\t\t\t //otherwise you have to install Rcpp.h and you need admin\n\t\t\t\t\t //privelege to do that.\n\n// Enable C++11 via this plugin (Rcpp 0.10.3 or later)\n// [[Rcpp::plugins(\"cpp11\")]]\t\t\t\t\t\t \n\nusing namespace std;\n\n//Some constant declarations\nconst int MINUS_INF = std::numeric_limits<int>::min()/2;\nconst int DEBUG = false;\nstring PAUSE = \"x\";\n\n\nclass Mutation_Info{\n\n\tprivate:\n\t\tconst unsigned int start;\n\t\tconst char original;\n\t\tconst char mutated;\n\n\tpublic:\n\n\t\t/**\n\t\tConstructor of the class, set atttributes to s,o and m.\n\n\t\tUse example:\n\t\t\tMutation_Info example(20,C,G)\n\t\t\tcout<<example.to_string()<<endl;\n\t\t*/\n\t\tMutation_Info(const int s, const char o, const char m):start(s),original(o),mutated(m){}\n\n\t\t/**\n\t\t\tThis function return an string representation of the object.\n\n\t\t\tThe string returned has the following format:\n\t\t\tSTART:    <start>\n\t\t\tORIGINAL: <original>\n\t\t\tMUTATED:  <mutated>\n\t\t\t\n\t\t\t@return string with the specified format.\n\t\t*/\n\t\tstring to_string() const{\n\n\t\t\tstring toReturn=\"START:    \" + std::to_string(start) + \"\\n\"+\n\t\t\t\t\t\t\t\"ORIGINAL: \" + original              + \"\\n\"+\n\t\t\t\t\t\t\t\"MUTATED:  \" + mutated               + \"\\n\";\n\n\t\t\treturn toReturn;\n\t\t};\n\n\t\t/**\n\n\t\t\tThis function return a string representation of the mutationl object\n\t\t\tin a compact format, like this:\n\t\t\t<start>,<original>,<mutated>\n\n\t\t*/\n\t\tstring to_string_lite() const{\n\n\t\t\treturn std::to_string(start) +\",\"+ original +\",\"+ mutated;\n\n\t\t};\n\n\t\t/**\n\t\t\tGet the 'start' attribute of the class.\n\n\t\t\t@return const unsigned int with the start\n\t\t*/\n\t\tinline const unsigned int get_start(){return start;};\n\n\t\t/**\n\t\t\tGet the 'original' attribute of the class.\n\n\t\t\t@return const char with the original nucleotide\n\t\t*/\n\t\tinline const unsigned int get_original(){return original;};\n\n\t\t/**\n\t\t\tGet the 'mutated' attribute of the class.\n\n\t\t\t@return const char with the mutation nucleotide\n\t\t*/\n\t\tinline const bool get_pattern(){return mutated;};\n\n};\n\n/**\nClass that represent Indel information.\n\nTwo sequences that are aligned can have several insertion or deletions. In order\nto track them we have a list of Indel_Info in each alignment.\n\nThe Indel_Info specify where the insertion or deletion start and ends. Also\nrefers if the indel is in the pattern or the subject. For example:\n\n         0123456789012345678\n         -------------------\nPattern  AATATAAC----GCACGTG \nSubject  AA--TAACGGAAGCACGTG \n\nThe Pattern have an insertion from 2 to 3.\nThe Pattern have a deletion from 8 to 11.\n\nThe Subject have the oposite respect the pattern:\n\nThe Subject have a deletion from 2 to 3.\nThe Subject have an insertion from 8 to 11.\n\n\n@invariant : end must be greater or equal than start\n@invariant : the length of the indel would be end-start+1\n\n*/\nclass Indel_Info{\n\t\n\tprivate:\n\t\tconst unsigned int start;\n\t\tconst unsigned int end;\n\t\tconst bool pattern;\n\tpublic:\n\t\n\t\t/**\n\t\tConstructor of the class, set atttributes to s,e and p.\n\n\t\tUse example:\n\t\t\tIndel_Info example(20,30,false)\n\t\t\tcout<<example.to_string()<<endl;\n\t\t*/\n\t\tIndel_Info(const int s, const int e, const bool p):start(s),end(e),pattern(p){}\n\n\t\t/**\n\t\t\tThis function return an string representation of the object.\n\n\t\t\tThe string returned has the following format:\n\t\t\tSTART: <start>\n\t\t\tEND:   <end>\n\t\t\t<\"In Pattern\",\"In Subject\">\n\n\t\t\t@return string with the specified format.\n\t\t*/\n\t\tstring to_string() const{\n\n\t\t\tstring toReturn=\"START: \"+std::to_string(start)+\"\\n\"+\n\t\t\t\t\t\t\t\"END:   \"+std::to_string(end)  +\"\\n\";\n\n\t\t\tif(pattern==true){ toReturn = \"In Pattern\\n\" + toReturn;}\n\t\t\telse{              toReturn = \"In Subject\\n\" + toReturn;}\n\n\t\t\treturn toReturn;\n\t\t};\n\n\t\t/**\n\n\t\t\tThis function return a string representation of the indel object in\n\t\t\ta compact format, like this:\n\t\t\t<start>,<end>\n\n\t\t*/\n\t\tstring to_string_lite() const{\n\n\t\t\treturn std::to_string(start)+\",\"+ std::to_string(end);\n\n\t\t}\n\n\t\t/**\n\t\t\tGet the 'start' attribute of the class.\n\n\t\t\t@return const unsigned int with the start\n\t\t*/\n\t\tinline const unsigned int get_start(){return start;};\n\n\t\t/**\n\t\t\tGet the 'end' attribute of the class.\n\n\t\t\t@return const unsigned int with the end\n\t\t*/\n\t\tinline const unsigned int get_end(){return end;};\n\n\t\t/**\n\t\t\tGet the 'pattern' attribute of the class.\n\n\t\t\t@return const bool with the pattern\n\t\t*/\n\t\tinline const bool get_pattern(){return pattern;};\t\n\n};\n\n/**\n\nThis class represent various information about an alignment. The members of the\nclass are described here:\n\n\t@see Indel_Info, in here you will find information about how the list of\n\t\t\t\t\t  indels is actually implemented.\n\t\t\t\t\t  \n\t@todo Is there actually a standard way to describe members?\n\n    const string pattern: One of the sequences that are aligned.\n    const string subject: The other sequence aligned.\n\n    const string scoreMatrix: Score matrix used to make this alignment.\n    const int gapOpening:     Score given for opening gaps.\n    const int gapExtension:   Score given for extending gaps.\n\n    const int alignmentLength: How long are both alignments counting gaps. \n    const int score:           Final score of the alignment.\n\n\tconst string patternAlignment: Alignment of the pattern.\n\tconst string markup:           String that compare visually both alignments.\n\tconst string subjectAlignment: Alignment of the subject.\n\n\tconst int totalInsertions: How many Insertion are in the alignments.\n\t\t\t\t\t\t\t   An Insertion is an insertion in the pattern or a\n\t\t\t\t\t\t\t   deletion in the subject.\n\tconst int totalDeletions:  How many Deletions are in the alignments.\n\t\t\t\t\t\t\t   A Deletion is a deletion in the pattern or an\n\t\t\t\t\t\t\t   insertion in the subject.\n\tconst int totalMismatches: How many mismatches are in between the two\n\t\t\t\t\t\t\t   sequences.\n\n\tconst std::list<Indel_Info> insertions: List with the insertions information\n\tconst std::list<Indel_Info> deletions:  List with the deletions information.\n  \n\n\t@invariant: length(patternAlignment) = length(subjectAignment) =\n\t            length(markup) = alignmentLength\n\n\t            length(pattern)<= alignmentLength\n\t            length(subject)<= alignmentLength\n\n\t            size(insertion) = totalInsertions\n\t            size(deletions) = totalDeletions\n\n\t            totalMismatches <= min(length(pattern),length(subject))\n\n*/\n/* I'm implementing this class so we can have an independent RCPP functions from\neverything else. The idea is to have a to_string method here so we can make\nan alignment function align() that return a Alignment_Results. And the RCPP\nfunction will just be alignRCPP(){return align().to_string()} so the core\nalign function is independent.\n\nMaybe in the future we decide to develop this library a little bit more and make\nmany RCPP dependencies.\n\n\n\t@todo Better container than just a fixed array? Is O(k), can't think of a\n\t      better k in this case.\n\n\tOriginally I thought of making this arrays for insertions and deletions\n\n\tconst Indel_Info* insertions: \n\tconst Indel_Info* deletions:\n\n\tI realized that we don't know indel in advance and until we finish the grid\n\tmatrix. So we need a mutable container. Afterward we would need to copy the\n\tlist into the array and allocate memory again; hence using the original list\n\tand save the time for the second allocation.\n\n*/\nclass Alignment_Result{\n\t\n\tprivate:\n\t\tconst string pattern;\n\t\tconst string subject;\n\n\t\tconst string scoreMatrix;\n\t\tconst int gapOpening;\n\t\tconst int gapExtension;\n\t\tconst bool gapEnding;\n\n\t\tconst int alignmentLength;\n\t\tconst int score;\n\n\t\tconst string patternAlignment;\n\t\tconst string markup;\n\t\tconst string subjectAlignment;\n\n\t\tconst int totalInsertions;\n\t\tconst int totalDeletions;\n\t\tconst int totalMismatches;\n\n\t\tconst std::list<Indel_Info> insertions;\n\t\tconst std::list<Indel_Info> deletions;\n\n\t\tconst std::list<Indel_Info> insertionsPattern;\n\t\tconst std::list<Indel_Info> deletionsSubject;\n\t\t\n\t\tconst std::list<Mutation_Info> mutations;\n\t\tconst std::list<Mutation_Info> mutationsRelative;\n\n\tpublic:\n\t\t/**\n\t\t\tConstructor of the class. Every element is initialize as const\n\t\t\tsince the result is fixed.\n\t\t*/\n\t\t//This is ugly :-(\n\t\tAlignment_Result(const string pattern, const string subject,\n\t\t\t\t\t\t const string scoreMatrix, const int gapOpening,\n\t\t\t\t\t\t const int gapExtension, const bool gapEnding,\n\t\t\t\t\t\t const int alignmentLength,\n\t\t\t\t\t\t const int score, const string patternAlignment,\n\t\t\t\t\t\t const string markup, const string subjectAlignment,\n\t\t\t\t\t\t const int totalInsertions,\tconst int totalDeletions,\n\t\t\t\t\t\t const int totalMismatches,\n\t\t\t\t\t\t const std::list<Indel_Info> insertions,\n\t\t\t\t\t\t const std::list<Indel_Info> deletions,\n\t\t\t\t\t\t const std::list<Indel_Info> insertionsPattern,\n\t\t\t\t\t\t const std::list<Indel_Info> deletionsSubject,\n\t\t\t\t\t\t const std::list<Mutation_Info> mutations,\n\t\t\t\t\t\t const std::list<Mutation_Info> mutationsRelative\n\t\t\t\t\t\t ):\n\n\t\t\t\t\t\t pattern(pattern),subject(subject),\n\t\t\t\t\t\t scoreMatrix(scoreMatrix),gapOpening(gapOpening),\n\t\t\t\t\t\t gapExtension(gapExtension), gapEnding(gapEnding),\n\t\t\t\t\t\t alignmentLength(alignmentLength),score(score),\n\t\t\t\t\t\t patternAlignment(patternAlignment), markup(markup),\n\t\t\t\t\t\t subjectAlignment(subjectAlignment),\n\t\t\t\t\t\t totalInsertions(totalInsertions),\n\t\t\t\t\t\t totalDeletions(totalDeletions),\n\t\t\t\t\t\t totalMismatches(totalMismatches),insertions(insertions)\n\t\t\t\t\t\t ,deletions(deletions),\n\t\t\t\t\t\t insertionsPattern(insertionsPattern),\n\t\t\t\t\t\t deletionsSubject(deletionsSubject),\n\t\t\t\t\t\t mutations(mutations),\n\t\t\t\t\t\t mutationsRelative(mutationsRelative){}\n\n\t\t/**\n\t\t\tThis function return an string representation of the object.\n\n\t\t\tThe string returned has the following format:\n\n\t\t\t*********************\n\t\t\tSEQUENCES INFORMATION\n\t\t\t*********************\n\t\t\tSCORING INFORMATION\n\t\t\t*********************\n\t\t\tRESULTS\n\t\t\t*********************\n\t\t\tINDELS AND MUTATIONS\n\t\t\t*********************\n\n\t\t\tIf the instance of the object is initialize to NULL it return a\n\t\t\twarning string message\n\n\t\t\t@return string with the specified format.\n\t\t*/\n\t\tstring to_string(){\n\n\t\t\tstring toReturn =  \"\";\n\t\t\t\n\t\t\tif(this==NULL){\n\n\t\t\t\ttoReturn = \"WARNING: Alignment_Result init to NULL\";\n\n\t\t\t}\n\t\t\telse{\n\n\t\t\t\tint totalChunks = 0;\n\t\t\t\tint lastChunkLength = 0;\n\t\t\t\tstring patternPiece = \"\";\n\t\t\t\tstring markupPiece  = \"\";\n\t\t\t\tstring subjectPiece = \"\";\n\t\t\t\tstring indelInfoPiece = \"\";\n\n\t\t\t\ttoReturn = toReturn +\n\t\t\t\t\"****************\\n\"+\n\t\t\t\t\"SEQUENCES \\n\"+\n\t\t\t\t\"----------------\\n\"+\n\t\t\t\t\"Pattern: \"+pattern + \"\\n\"+\n\t\t\t\t\"Subject: \"+subject + \"\\n\"+\n\t\t\t\t\"****************\\n\"+\n\t\t\t\t\"SCORING INFO \\n\"+\n\t\t\t\t\"----------------\\n\"+\n\t\t\t\t\"Score matrix:       \"+scoreMatrix+\"\\n\"+\n\t\t\t\t\"Gap opening:        \"+std::to_string(gapOpening)+\"\\n\"+\n\t\t\t\t\"Gap extension:      \"+std::to_string(gapExtension)+\"\\n\"+\n\t\t\t\t\"Gap ending penalty: \"+std::to_string(gapEnding)+\"\\n\"+\n\t\t\t\t\"****************\\n\"+\n\t\t\t\t\"RESULTS \\n\"+\n\t\t\t\t\"----------------\\n\"+\n\t\t\t\t\"Alignment Length: \"+std::to_string(alignmentLength)+\"\\n\"+\n\t\t\t\t\"Score: \"+std::to_string(score) + \"\\n\\n\";\n\n\t\t\t\t//Now lets separate the aligns in chunks of lenght 80\n\t\t\t\ttotalChunks = alignmentLength/80;\n\t\t\t\tlastChunkLength = alignmentLength%80;\n\n\t\t\t\t//Print all the chunks of length 80\n\t\t\t\tfor(int i=0; i<totalChunks; i++){\n\t\t\t\t\tpatternPiece = patternAlignment.substr(80*i,80);\n\t\t\t\t\tmarkupPiece  = markup.substr(80*i,80);\n\t\t\t\t\tsubjectPiece = subjectAlignment.substr(80*i,80);\n\n\t\t\t\t\ttoReturn = toReturn +\n\t\t\t\t\tpatternPiece + \"    \" + std::to_string(80*(i+1)) + \"\\n\"+\n\t\t\t\t\tmarkupPiece + \"    \\n\"+\n\t\t\t\t\tsubjectPiece + \"    \\n\\n\";\n\t\t\t\t}\n\n\t\t\t\t//Print the last chunk that didn't reach to 80\n\t\t\t\tif(lastChunkLength>0){\n\t\t\t\t\tpatternPiece = patternAlignment.substr(totalChunks*80,lastChunkLength);\n\t\t\t\t\tmarkupPiece  = markup.substr(totalChunks*80,lastChunkLength);\n\t\t\t\t\tsubjectPiece = subjectAlignment.substr(totalChunks*80,lastChunkLength);\n\n\t\t\t\t\ttoReturn = toReturn +\n\t\t\t\t\tpatternPiece + \"    \" + std::to_string(alignmentLength) + \"\\n\"+\n\t\t\t\t\tmarkupPiece + \"    \\n\"+\n\t\t\t\t\tsubjectPiece + \"    \\n\";\n\t\t\t\t}\n\n\n\t\t\t\ttoReturn = toReturn +\n\t\t\t\t\"****************\\n\"+\n\t\t\t\t\"ALIGNMENT INFO \\n\"+\n\t\t\t\t\"----------------\\n\"+\n\t\t\t\t\"Total Insertions: \"+std::to_string(totalInsertions)+\"\\n\"+\n\t\t\t\t\"Total Deletions:  \"+std::to_string(totalDeletions)  +\"\\n\"+\n\t\t\t\t\"Total Mismatches: \"+std::to_string(totalMismatches) +\"\\n\"+\n\t\t\t\t\"----------------\\n\"+\n\t\t\t\t\"INSERTIONS: \\n\"+\n\t\t\t\t\"----------------\\n\";\n\n\t\t\t\t//Show the list of all insertions\n\t\t\t\tfor (list<Indel_Info>::const_iterator it = insertions.begin();\n\t\t\t\t     it!=insertions.end(); it++){\n\n\t\t\t\t\tindelInfoPiece += (*it).to_string() + \"\\n\";\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\ttoReturn = toReturn + indelInfoPiece + \"\\n\" +\n\n\t\t\t\t\"--Insertions respect patterns coordinates-- \\n\\n\";\n\n\t\t\t\tindelInfoPiece = \"\";\n\n\t\t\t\t//Show the list of all deletions from the subject coordinates.\n\t\t\t\tfor (list<Indel_Info>::const_iterator it = insertionsPattern.begin();\n\t\t\t\t     it!=insertionsPattern.end(); it++){\n\n\t\t\t\t\tindelInfoPiece += (*it).to_string() + \"\\n\";\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\ttoReturn += indelInfoPiece + \"\\n\" +\n\n\t\t\t\t\n\t\t\t\t\"----------------\\n\"+\n\t\t\t\t\"DELETIONS: \\n\"+\n\t\t\t\t\"----------------\\n\";\n\t\t\t\t\n\t\t\t\tindelInfoPiece = \"\";\n\n\t\t\t\t//Show the list of all deletions\n\t\t\t\tfor (list<Indel_Info>::const_iterator it = deletions.begin();\n\t\t\t\t     it!=deletions.end(); it++){\n\n\t\t\t\t\tindelInfoPiece += (*it).to_string() + \"\\n\";\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\ttoReturn = toReturn + indelInfoPiece + \"\\n\" +\n\n\t\t\t\t\"--Deletions respect subject coordinates-- \\n\\n\";\n\n\t\t\t\tindelInfoPiece = \"\";\n\t\t\t\t\n\t\t\t\t//Show the list of all deletions from the subject coordinates.\n\t\t\t\tfor (list<Indel_Info>::const_iterator it = deletionsSubject.begin();\n\t\t\t\t     it!=deletionsSubject.end(); it++){\n\n\t\t\t\t\tindelInfoPiece += (*it).to_string() + \"\\n\";\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\ttoReturn += indelInfoPiece + \"\\n\" +\n\t\t\t\n\t\t\t\t\"----------------\\n\"+\n\t\t\t\t\"MISMATCHES: \\n\"+\n\t\t\t\t\"----------------\\n\";\n\n\t\t\t\tindelInfoPiece = \"\";\n\n\t\t\t\t//Show the list of all missmatches\n\t\t\t\tfor (list<Mutation_Info>::const_iterator it = mutations.begin();\n\t\t\t\t     it!=mutations.end(); it++){\n\n\t\t\t\t\tindelInfoPiece += (*it).to_string() + \"\\n\";\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\ttoReturn = toReturn + indelInfoPiece + \"\\n\" +\n\n\t\t\t\t\"--Missmatches respect subject coordinates-- \\n\\n\";\n\n\t\t\t\tindelInfoPiece = \"\";\n\n\t\t\t\t//Show the list of all missmatches\n\t\t\t\tfor (list<Mutation_Info>::const_iterator it = mutationsRelative.begin();\n\t\t\t\t     it!=mutationsRelative.end(); it++){\n\n\t\t\t\t\tindelInfoPiece += (*it).to_string() + \"\\n\";\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\ttoReturn += indelInfoPiece + \"\\n\" +\n\t\t\t\t\n\t\t\t\t\"\\n\"+\n\t\t\t\t\"****************\\n\";\n\t\t\t}\n\t\t\t\n\t\t\treturn toReturn;\n\t\t}\n\t\t\n\t\t/**\n\t\t\tThis function return an string representation of the object. In this\n\t\t\tcase the information given is the minimum that ggplot2 needs to draw\n\t\t\tthe information about the alignments\n\n\t\t\tThe string returned have this format:\n\n\t\t\t<number of insertions>@<insertion 0 start>,<insertion 0 end>*\n\t\t\t<insertion 1 start>,<insertion 1 end>*...,<insertion N end>*!\n\t\t\t<number of deletions>@<deletion 0 start>,<deletion 0 end>*\n\t\t\t<deletion 1 start>,<deletion 1 end>*...,<deletion M end>*!\n\t\t\t<number of mutations>@<mutation 0 start>,<mutation 0 original>,\n\t\t\t<mutation 0 mutated>*<mutation 1 start>,<mutation 1 original>,\n\t\t\t<mutation 1 mutated>*...,<mutation X start>,<mutation X original>,\n\t\t\t<mutation X mutated>*\n\n\t\t\t @see ggplot2\n\t\t\t @todo info to ggplot2 specifications\n\t\t\t @see ampliCan.R\n\t\t\t @todo link to specific lines of code in the R script\n\t\t\t @todo CIGAR \n\n\t\t*/\n\t\tstring to_ggplot2_string(){\n\n\t\t\tstring toReturn = \"\";\n\n\t\t\tint totalInsertions = insertions.size();\n\t\t\tint totalDeletions = deletions.size();\n\n\t\t\t//Add the insertions info\n\t\t\ttoReturn += \"@\" + std::to_string(totalInsertions) + \"@\";\n\n\t\t\tfor (list<Indel_Info>::const_iterator it = insertions.begin();\n\t\t\t\tit!=insertions.end(); it++){\n\n\t\t\t\ttoReturn += (*it).to_string_lite() + \"*\";\n\t\t\t}\n\n\t\t\t//Make a character that separate the insertions from deletions\n\t\t\ttoReturn += \"!\";\n\n\t\t\t//Add the deletions info\n\t\t\ttoReturn += \"@\" + std::to_string(totalDeletions) + \"@\";\n\n\t\t\tfor (list<Indel_Info>::const_iterator it = deletions.begin();\n\t\t\t\tit!=deletions.end(); it++){\n\n\t\t\t\ttoReturn += (*it).to_string_lite() + \"*\";\n\t\t\t}\n\n\t\t\t//Make a character that separate the deletions from mutations\n\t\t\ttoReturn += \"!\";\n\n\t\t\t//Add the mutations info\n\t\t\ttoReturn += \"@\" + std::to_string(totalMismatches) + \"@\";\n\n\t\t\tfor (list<Mutation_Info>::const_iterator it = mutations.begin();\n\t\t\t\tit!=mutations.end(); it++){\n\n\t\t\t\ttoReturn += (*it).to_string_lite() + \"*\";\n\t\t\t}\n\n\t\t\t return toReturn;\n\n\t\t}\n\n\t\tstring to_subject_coordiantes_string(){\n\n\t\t\tstring toReturn = \"\";\n\n\t\t\tint totalInsertions = insertions.size();\n\t\t\tint totalDeletions = deletions.size();\n\n\t\t\t//Add the insertions info\n\t\t\ttoReturn += \"@\" + std::to_string(totalInsertions) + \"@\";\n\n\t\t\tfor (list<Indel_Info>::const_iterator it = insertions.begin();\n\t\t\t\tit!=insertions.end(); it++){\n\n\t\t\t\ttoReturn += (*it).to_string_lite() + \"*\";\n\t\t\t}\n\n\t\t\t//Make a character that separate the insertions from deletions\n\t\t\ttoReturn += \"!\";\n\n\t\t\t//Add the deletions info\n\t\t\ttoReturn += \"@\" + std::to_string(totalDeletions) + \"@\";\n\n\t\t\tfor (list<Indel_Info>::const_iterator it = deletionsSubject.begin();\n\t\t\t\tit!=deletionsSubject.end(); it++){\n\n\t\t\t\ttoReturn += (*it).to_string_lite() + \"*\";\n\t\t\t}\n\n\t\t\t//Make a character that separate the deletions from mutations\n\t\t\ttoReturn += \"!\";\n\n\t\t\t//Add the mutations info\n\t\t\ttoReturn += \"@\" + std::to_string(totalMismatches) + \"@\";\n\n\t\t\tfor (list<Mutation_Info>::const_iterator it = mutationsRelative.begin();\n\t\t\t\tit!=mutationsRelative.end(); it++){\n\t\t\t\t\t\n\t\t\t\ttoReturn += (*it).to_string_lite() + \"*\";\n\t\t\t}\n\n\t\t\t return toReturn;\n\n\t\t}\n\n\t\t/**\n\t\t\tReturn only the insertions information in a string format:\n\t\t\tStart@End@<Pattern,Subject>\n\t\t*/\n\t\tstring insertions_to_string(){return \"\";}\n\n\t\t/**\n\t\t\tReturn only the insertions information in a string format:\n\t\t\tStart@End@<Pattern,Subject>\n\t\t*/\t\t\n\t\tstring delitions_to_string(){return \"\";}\n\n\t\tstring get_pattern_alignment(){ return patternAlignment ;}\n\t\tstring get_subject_alignment(){ return subjectAlignment ;}\n\n};\n\n/**\n\n\tPrint a 2D matrix with generic variable type T, that has a pattern and a\n\tsubject related to it. Also print the pattern on top and the subject on the\n\tleft side.\n\n\t@precond\n\t\tThe matrix is size N x M\n\t\tThe pattern must be of length M-1\n\t\tThe subject must be of length N-1\n\n\t@todo Can T be converted to const T? function outside class is not allowed\n\t      to have printMatrix() const {} declaration.\n\n    @param T** matrix: The matrix we want to print on standard output\n    @param string sequencePattern: String with the pattern sequence\n\t@param string sequenceSubject: String with the subject sequence\n\t\n    @return VOID\n*/\ntemplate <class T>\nvoid printMatrix(T** matrix, const string &sequencePattern,\n                  const string &sequenceSubject){\n\n\t//Get the length of each sequence\n\tint lengthPattern = sequencePattern.length();\n    int lengthSubject = sequenceSubject.length();\n\n\t//Print the first row which is the pattern on top\n    cout << \"    \";\n    for(int i=0; i<lengthPattern;i++){\n\t\tcout << sequencePattern[i] << \" \";\n\t}\n    cout << \"\\n\";\n\n\t//Print the rest of the lines starting with the subject nucleotide\n\tfor(int i=0;i<=lengthSubject;i++){\n\t\t\n\t\t//If it is the first character, show the subject nucleotide\n\t\tif(i>0){\n\t\t\tcout <<sequenceSubject[i-1]<< \" \";\n\t\t}\n\t\t//Otherwise leave a nice spacing from the nucleotide\n\t\telse{\n\t\t\tcout<<\"  \";\n\t\t}\n\n\t\t//Continue with the rest of the row\n\t\tfor(int j = 0; j<=lengthPattern; j++){\n\n\t\t\t//If we are printing numbers\n\t\t\tif (typeid(T) == typeid(int)){\n\n\t\t\t\tif(matrix[i][j] <= MINUS_INF){   //If the number is very low\n\t\t\t\t\t\t\t\t\t\t\t\t //is the same as -infinity\n\t\t\t\t\tcout<<\"-∞ \";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t//Positives numbers carry a \"+\" to compensate aligning\n\t\t\t\t\t//with negatives numbers that carry a \"-\" symbol.\n\t\t\t\t\tif(matrix[i][j]>=0){\n\t\t\t\t\t\tcout<<\"+\";\n\t\t\t\t\t}\n\t\t\t\t\tcout<<matrix[i][j]<< \" \";\n\t\t\t\t}\n\t\t\t}\n\t\t\t//If we print something else\n\t\t\telse{\n\t\t\t\tcout<<matrix[i][j]<< \" \";\n\t\t\t}\n\t\t}\n\t\tcout<<\"\\n\";\n\t}\n}\n\n/**\n\n\tReturn the maximum of every integer that is on a row of a 2D matrix.\n\n*/\ninline int maxRow(int** matrix, const int &columnIndex, const int &totalRows,\n\t\t\t\t  unsigned int &maximumIndex, const int &offset = 0){\n\n\n\tint maximum = matrix[offset][columnIndex];\n\tmaximumIndex = offset;\n\t\n\t//For each of the elements in the row\n    for(int i=offset+1; i<=totalRows; i++){ //+1, maximum is [i][0], start in [i][1]\n\t\tif(maximum < matrix[i][columnIndex]){\n\n\t\t\tmaximum = matrix[i][columnIndex];\n\t\t\tmaximumIndex = i;\n\n\t\t}\t\t\n\t}\n\n\treturn maximum;\n\n}\n\n/**\n\n\tReturn the maximum of every integer that is on a column of a 2D matrix.\n\n*/\ninline int maxColumn(int** matrix, const int &rowIndex, const int &totalColumns,\n\t\t\t\t  unsigned int &maximumIndex, const int &offset = 0){\n\n\n\tint maximum = matrix[rowIndex][offset];\n\tmaximumIndex = offset;\n\t\n\t//For each of the elements in the row\n    for(int i=offset+1; i<=totalColumns; i++){ //+1, maximum is [i][0], start in [i][1]\n\n\t\tif(maximum < matrix[rowIndex][i]){\n\n\t\t\tmaximum = matrix[rowIndex][i];\n\t\t\tmaximumIndex = i;\n\n\t\t}\t\t\n\t}\n\n\treturn maximum;\n\n}\n\n/**\n\t\n\tReturn the maximum of three integers. The character indicates\n\tthe direction of the traceback matrix propagation, like this:\n\t \n\t-----------\n\t| B  |  A |\n\t-----------\n\t| C  |  X |\n\t-----------\n\n    @param int A,B,C: Integer from where we get the maximum, which will\n\t\t\t\t\t  max(A,B,C).\n\n\t@param direction: A character that represent the direction that we shall\n\t\t\t\t\t  follow from X in order to get to the maximum. '-' for C\n\t\t\t\t\t  '\\' for B and '|' for A. WILL BE MODIFY.\n\t\t\t\t\t  \n    @return int max: A copy of either, A, B or C.\n*/\ninline int max(int A, int B, int C, char &direction){\n\tint  max = -999999 ;\n\n\tif(B>=A && B>=C){\n\t\tmax = B ;\n        direction = '\\\\' ;\n\t}\n    else if(A>=C){\n\t\tmax = A;\n        direction = '|';\n\t}\n    else{\n\t\tmax = C ;\n        direction = '-' ;\n\t}\n\n    return  max ;   \n}\n\n/**\n\t\n\tReturn the maximum of three integers. The character indicates the direction\n\tof the traceback matrix propagation. A '\\' character means that we continue\n\tin the traceback grid matrix. A 'V' character means that we should go to the\n\tvertical traceback matrix. A 'H' chracter means that we should go to the\n\thorizontal traceback matrix.\n\t \n    @param int grid,vertical,horizontal: Integers from where we get the maximum,\n\t\t\t\t\t\t\t\t\t\t which will max(G,V,H).\n\n\t@param direction: A character that represent the direction that we shall\n\t\t\t\t\t  follow in order to get to the maximum. 'H' for horizontal\n\t\t\t\t\t  '\\' for grid and 'V' for vertical. WILL BE MODIFY.\n\t\t\t\t\t  \n    @return int max: A copy of either, grid, vertical or horizontal.\n*/\ninline int max3D(int grid, int vertical, int horizontal, char &direction){\n\tint  max = -999999 ;\n\n    if(grid>=vertical && grid>=horizontal){\n\t\tmax = grid;\n        direction = '\\\\';\n\t}\n    else if(vertical>=horizontal){\n\t\tmax = vertical ;\n        direction = 'H' ;\n\t}\n    else{\n\t\tmax = horizontal ;\n        direction = 'V' ;\n\t}\n\n    return  max ;   \n}\n\n/**\n\n\tReturn the maximum of two integer. The maximum represent which path is\n\tbetter to take in order to make the alignment.\n\n\tIf the maximum is 'open' it means that we need to go to the grid traceback\n\tand check where does it take us. We label direction with a 'G'.\n\n\tIf the maximum is 'extend' it means that we need to keep going in the\n\tvertical traceback. We label direction with a '|'\n\n\t@param int open, extend: Integer from where we get the maximum. The maximum\n\t\t\t\t\t\t\t will be max(open,extend)\n\n\t@param direction: \t\t A character that represent which direction shall\n\t\t\t\t\t\t\t we follow; 'G' for open, and '|' for extend.\n\t\t\t\t\t\t\t WILL BE MODIFY.\n*/\ninline int maxHorizontal(const int &open, const int &extend, char &direction){\n\n\tint  max = -999999 ;\n\n    if(open>=extend){\n\t\tmax = open;\n        direction = 'G';\n\t}\n    else{\n\t\tmax = extend;\n        direction = '-';\n\t}\n\t\n    return  max ;   \n}\n\n/**\n\n\tReturn the maximum of two integer. The maximum represent which path is\n\tbetter to take in order to make the alignment.\n\n\tIf the maximum is 'open' it means that we need to go to the grid traceback\n\tand check where does it take us. We label direction with a 'G'.\n\n\tIf the maximum is 'extend' it means that we need to keep going in the\n\thorizontal traceback. We label direction with a '-'\n\n\t@param int open, extend: Integer from where we get the maximum. The maximum\n\t\t\t\t\t\t\t will be max(open,extend)\n\n\t@param direction: \t\t A character that represent which direction shall\n\t\t\t\t\t\t\t we follow; 'G' for open, and '-' for extend.\n\t\t\t\t\t\t\t WILL BE MODIFY.\n*/\ninline int maxVertical(const int &open, const int &extend, char &direction){\n\n\tint  max = -999999;\n\n    if(open>=extend){\n\t\tmax = open;\n        direction = 'G';\n\t}\n    else{\n\t\tmax = extend;\n        direction = '|';\n\t}\n\t\n    return  max ;   \n}\n\n/**\n\n\tInitialize SIX matrices.\n\n\tOne represent the integer grid where the algorithm propagates and find\n\tthe maximum alignment score.\n\n\tIt is initialize as:\n\tgrid[0][0] = 0\n\tgrid[i][0] = -infinity (i!=0)\n\tgrid[0][j] = -infinity (j!=0)\n\n\tThe other two integer matrices represent the gap extension algorithm.\n\tIn this case one resolve horizontally while the other does vertically.\n\n\tThey are initialize as:\n\tvertical[0][j] = - (gapOpening + gapExtension*j)\n\tvertical[i][0] = - infinity (i!=0)\n\n\thorizontal[i][0] = - (gapOpening + gapExtension*i)\n\thorizontal[0][j] = - infinity (j!=0)\n\n\tThe other ones represent the direction of the propagatation. Encoded\n\tin chars with an ASCII style.\n\n\tThey are initialize as:\n\ttracebackGrid[0][0] = x (representing the finish point)\n\ttracebackGrid[0][j] = H (representing \"go to horizontal matrix\") (j!=0)\n\ttracebackGrid[i][0] = V (representing \"go to vertical   matrix\") (i!=0)\n\n\ttracebackVertical[0][j] = G (representing \"go to grid\") \n\ttracebackVertical[i][0] = | (representing \"go up     \") (i!=0)\n\n\ttracebackHorizontal[i][0] = G (representing \"go to grid\")\n\ttracebackHorizontal[0][j] = - (representing \"go to left\") (j!=0)\n\n\tHere is an example for every matrix initialize with:\n\tGap opening = -10\n\tGap extension = -2\n\n\tGRID:\n\t    \n\t-----------------------------------------\n\t|   |   | A | T | C | G | G | G | A | G |\n\t-----------------------------------------\n\t|   | 0 |-in|-in|-in|-in|-in|-in|-in|-in|\n\t-----------------------------------------\n\t| A |-in|   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n\t| T |-in|   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n\t| C |-in|   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n \t| G |-in|   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n\n\tVERTICAL:\n\t    \n\t-----------------------------------------\n\t|   |   | A | T | C | G | G | G | A | G |\n\t-----------------------------------------\n\t|   |-10|-12|-14|-16|-18|-20|-22|-24|-26|\n\t-----------------------------------------\n\t| A |-in|   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n\t| T |-in|   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n\t| C |-in|   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n \t| G |-in|   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n\n\tHORIZONTAL:\n\t    \n\t-----------------------------------------\n\t|   |   | A | T | C | G | G | G | A | G |\n\t-----------------------------------------\n\t|   |-10|-in|-in|-in|-in|-in|-in|-in|-in|\n\t-----------------------------------------\n\t| A |-12|   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n\t| T |-14|   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n\t| C |-16|   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n \t| G |-18|   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n\n\tTRACEBACK GRID:\n\n\t-----------------------------------------\n\t|   |   | A | T | C | G | G | G | A | G |\n\t-----------------------------------------\n\t|   | x | H | H | H | H | H | H | H | H |\n\t-----------------------------------------\n\t| A | V |   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n\t| T | V |   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n\t| C | V |   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n \t| G | V |   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n\n\tTRACEBACK VERTICAL:\n\n\t-----------------------------------------\n\t|   |   | A | T | C | G | G | G | A | G |\n\t-----------------------------------------\n\t|   | G | G | G | G | G | G | G | G | G |\n\t-----------------------------------------\n\t| A | | |   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n\t| T | | |   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n\t| C | | |   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n \t| G | | |   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n\n\tTRACEBACK HORIZONTAL:\n\n\t-----------------------------------------\n\t|   |   | A | T | C | G | G | G | A | G |\n\t-----------------------------------------\n\t|   | G | - | - | - | - | - | - | - | - |\n\t-----------------------------------------\n\t| A | G |   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n\t| T | G |   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n\t| C | G |   |   |   |   |   |   |   |   |\n\t-----------------------------------------\n \t| G | G |   |   |   |   |   |   |   |   |\n\t-----------------------------------------\t\n\n\n\tNOTE: Since integer are a finite set in C++, we are using the upper or lower\n\tlimit to flag the infinity value. As std::numeric_limits<int>::max(). This\n\tgives a limit to the maximum score of the matrix of ~32K if we use 16 bit\n\trepresentation of signed integers.\n\n\tSince we are expecting sequences of maximum 500 nucleotides, and the NUC44\n\tmatrix maximum score is 5; we got a maximum score possible of two equal\n\tsequence as 5 * 500 = 2500. That gives ample margin to operate and not to\n\trun into an OVERFLOW situation (which would be around 6500 nucleotides)\n\n\tHowever, for the lower limit std::numeric_limits<int>::min(), we need to\n\tmake an slight ajustment. The minimum will OVERFLOW as soon as we find the\n\tscore of min()-gapOpening. For that reason, the -infinity is going to be\n\trepresented as anything bellow min()/2. We will initialize -infinity to that\n\tnumber. Again, with a 16 bit integer representation it will set around the\n\tnumber - ~16K. This means that, the worse case scenario is an alignment of\n\tsimilarity 0% that has length subject+pattern, ie:\n\t\n\t\t----AAAAAAA\n\t\tTTTT-------\n\n\tWe are expecting sequences of 500 nucleotides.\n\t\n\t- Worse case where all nucleotides are align but difference gives us a score\n\t  of 500 * (-4) = -2500 (again, no problem here).\n\n\t- Worse case where all nucleotides are UNALIGN give us a score of:\n\t\t-(Opening + 500*Extension)*2 . This equation must never be smaller than\n\t\tthe minimum set for - infinity. In the case where we set up for -16K:\n\t\t2*O + 1000*E > -16K => O + 500*E > -8K. This give us a margin of around\n\t\tgap extension ~= 16. This is something worth discussing for minimal\n\t\tmemory comsumption if 16bits representation of integer is used.\n\t\t\n\n\tNOTE2: The char** matrices are implemented with chars, only for the user\n\tconvinience. The horizontal and vertical are possible to implement with a\n\tbool since they only have two states (go <up,left> or go to grid). The grid\n\ttraceback needs THREE states that can be accomplished with only a double\n\tbool struct. After testing, it would be great to optimize that.\n\t\n\n  @param int** grid, horizontal, vertical: The three scoring matrices that\n\t\t\t\t\t\t\t\t\t\t\t were PREVIOUSLY CREATED which we\n\t\t\t\t\t\t\t\t\t\t\t are going to initialize properly.\n\n\t@param char** tracebackGrid, tracebackHorizontal, tracebackVertical:\n\n\t\t\t\t\t\t\t\t\t\t\t The three traceback matrices that\n\t\t\t\t\t\t\t\t\t\t\t were PREVIOUSLY CREATED which we\n\t\t\t\t\t\t\t\t\t\t\t are going to initialize properly.\n\n\t@param int lengthPattern, lengthSubject:\n\n\t\t\t\t\t\t\t\t\t\t\t The length of the two sequences.\n\n\t@param int gapOpening, gapExtension:\n\n\t\t\t\t\t\t\t\t\t\t\t The scoring for the gaps.\n\n\t@param bool gapEnding:\n\n\t\t\t\t\t\t\t\t\t\t\t Set to TRUE if you want that the\n\t\t\t\t\t\t\t\t\t\t\t score is affected by the gaps\n\t\t\t\t\t\t\t\t\t\t\t at the end of the alignment. FALSE\n\t\t\t\t\t\t\t\t\t\t\t for otherwise. (FALSE default)\n\n    @return VOID\n*/\nvoid  initialize(int** grid, int** vertical, int** horizontal,\n\t\t\t\t char** tracebackGrid, char** tracebackHorizontal,\n\t\t\t\t char** tracebackVertical, const string &sequencePattern,\n\t\t\t\t const string &sequenceSubject, const int &gapOpening,\n\t\t\t\t const int &gapExtension, const bool &gapEnding){\n\n\tint i = 0; //Reserve memory for index only once\n\n    const int lengthPattern = sequencePattern.length();\n    const int lengthSubject = sequenceSubject.length();\n\t\n\t//Initialize grid\n\tgrid[0][0] = 0 ;\n\n\t//We have two diferent inicializations, depending if we count the ending\n\t//of the alignments as 0 or whatever gap penalty.\n\tfor(i=1; i<=lengthPattern; i++){\n\t\t//grid[0][i] = -(gapOpening + gapExtension * i);\n\t\tgrid[0][i] = 0;\n\t}\n\tfor(i=1; i<=lengthSubject; i++){\n\t\t//grid[i][0] = -(gapOpening + gapExtension * i);\n\t\tgrid[i][0] = 0;\n\t}\n\t\n\tif(DEBUG==true){\n\t\tcout<<\"Grid initialized\"<<endl;\n\t}\n\n\t//Initialize horizontal\n\tfor(i=1; i<=lengthPattern; i++){\n\t\thorizontal[0][i] = -(gapOpening + gapExtension * i);\n\t}\n    for(i=0; i<=lengthSubject; i++){\n\t\thorizontal[i][0] = MINUS_INF;\n\t}\n\n\tif(DEBUG==true){\n\t\tcout<<\"Horizontal initialized\"<<endl;\n\t}\n\t\n\t//Initialize vertical\n    for(i=1; i<=lengthSubject; i++){\n\t\tvertical[i][0] = -(gapOpening + gapExtension * i);\t\t\n\t}\n\tfor(i=0; i<=lengthPattern; i++){\n\t\tvertical[0][i] = MINUS_INF;\t\t\n\t}\n\n\tif(DEBUG==true){\n\t\tcout<<\"Vertical initialized\"<<endl;\n\t}\n\t\n\t//Initialize tracebackGrid\n\ttracebackGrid[0][0] = 'x';\n\n    for(i=1; i<=lengthPattern; i++){\n\t\ttracebackGrid[0][i] = '-';\n\t}\n\tfor(i=1; i<=lengthSubject; i++){\n\t\ttracebackGrid[i][0] = '|';\n\t}\n\n\t//Initialize tracebackVertical\n\tfor(i=1; i<=lengthSubject; i++){\n\t\ttracebackVertical[i][0] = '|';\n\t}\n    for(i=0; i<=lengthPattern; i++){\n\t\ttracebackVertical[0][i] = 'G';\n\t}\n\n\t//Initialize tracebackHorizontal\n    for(i=1; i<=lengthPattern; i++){\n\t\ttracebackHorizontal[0][i] = '-';\n\t}\n\tfor(i=0; i<=lengthSubject; i++){\n\t\ttracebackHorizontal[i][0] = 'G';\n\t}\n\n\tif(DEBUG==true){\n\n\t\tcout<<\"DEBUG in initialize\"<<endl;\n\t\tcout<<\"Ending of initialize \"<<endl;\n\t\tcout<<\"Grid matrix\"<<endl;\n\t\tprintMatrix(grid, sequencePattern, sequenceSubject);\n\t\tcout<<endl;\n\t\tcout<<\"Vertical matrix\"<<endl;\n\t\tprintMatrix(vertical, sequencePattern, sequenceSubject);\n\t\tcout<<endl;\n\t\tcout<<\"Horizontal matrix\"<<endl; \n\t\tprintMatrix(horizontal, sequencePattern, sequenceSubject);\n\t\tcout<<endl;\n\t\tcout<<\"Traceback Grid matrix\"<<endl;\n\t\tprintMatrix(tracebackGrid, sequencePattern, sequenceSubject);\n\t\tcout<<endl;\n\t\tcout<<\"Traceback Vertical matrix\"<<endl;\n\t\tprintMatrix(tracebackVertical, sequencePattern, sequenceSubject);\n\t\tcout<<endl;\n\t\tcout<<\"Traceback Horizontal matrix\"<<endl;\n\t\tprintMatrix(tracebackHorizontal, sequencePattern, sequenceSubject);\n\t\tcout<<endl;\n\t\tcout<<\"END DEBUG in initialize\"<<endl<<endl;\n\t}\n\n}\n\n\n/**\n    This function allow you to align two sequences, provided that the grid\n    matrices and the traceback matrices are inicialized.\n\n    @param \n    @return 0 if everything goes well\n            1 if you choose a wrong scoring matrix;\n              this will swap to NUC44 and run the function anyway\n*/\nint align(int** grid, int** vertical, int** horizontal, char** tracebackGrid,\n\t\t  char** tracebackVertical, char** tracebackHorizontal,\n\t\t  const string &sequencePattern, const string &sequenceSubject,\n\t\t  const string &matrix, const int &gapOpening,\n\t\t  const int &gapExtension, const bool &gapEnding,\n\t\t  const bool &farIndels, Alignment_Result* &myResult){\n\n\tif(DEBUG==true){\n\n\t\tcout<<\"Function Align called with parameters:\"<<endl;\n\t\tcout<<\"G Opening: \"<<gapOpening<<endl;\n\t\tcout<<\"G Extensi: \"<<gapExtension<<endl;\n\t\tcout<<\"G Ending : \"<<gapEnding<<endl;\n\n\t}\n\n  //The return parameter\n  int toReturn = 0;\n\n\t//Find out coordinates in scoring matrix\n\tint x = 0;\n\tint y = 0;\n\n\t//Variables for finding max scores\n\tint up = 0;\n\tint diagonal = 0;\n\tint left = 0;\n\tint newGap = 0;\n\tint extendGap = 0;\n\n\t//Auxiliary variables to store nucleotides and direction chars\n  char direction = 'x';\n  char nucleotide = 'x';\n\n  //Indexes for the loops\n  unsigned int i=0;\n  unsigned int j=0;\n\n  //Scoring variables\n  unsigned int maximumIndex=0;\n  int maxScore = 0;\n    \n  //The result of the alignment is store in here\n  string patternResult = \"\";\n  string subjectResult = \"\";\n  string markup = \"\";\n\n\t//The list of insertions and deletions\n  std::list<Indel_Info> insertions;\n  std::list<Indel_Info> deletions;\n  std::list<Indel_Info> insertionsPattern;\n  std::list<Indel_Info> deletionsSubject;\n  int indelEnd = 0;\n  int indelStart = 0;\n\n\tint indelSubjectStart = 0;\n\tint indelSubjectEnd = 0;\n\tint indelPatternStart = 0;\n\tint indelPatternEnd = 0;\n\tint subjectIndex = 0;\n\tint patternIndex = 0;\n\n\t//The list of mutations\n\tstd::list<Mutation_Info> mutations;\n\tstd::list<Mutation_Info> mutationsRelative;\n\t//int  mutationStart = 0;\n\t//char mutationOriginal = 'Z';\n\t//char mutationMutated  = 'Y';\n\n  //Auxiliary stuff\n  bool gapFound = 0;\n  char currentNucleotide  = 'x';\n\n\t//Scoring matrix structure (init to NUC44 by default)\n\tint  scoreMatrix[4][4] = {{ 5, -4, -4, -4 },    \n\t\t\t\t\t\t\t  {-4,  5, -4, -4 },\n\t\t\t\t\t\t\t  {-4, -4,  5, -4 },\n\t\t\t\t\t\t\t  {-4, -4, -4,  5}};\n\n\t//Get the length of the sequences\n  unsigned int  lengthPattern = sequencePattern.length();\n  unsigned int  lengthSubject = sequenceSubject.length();\n\n\t//Set up the scoring matrix\n\t/**@todo set up other matrices*/\n\tif( matrix!=\"NUC44\"){\n\t\ttoReturn = 1;\n\t}\n\n\t//For each of the subject nucleotides\n    for(i=1; i<=lengthSubject; i++){\n\n\t\t//For each of the pattern nucleotides\n\t\tfor(j=1; j <= lengthPattern; j++){\n\n\t\t\t//Get the nucleotide of the Pattern\n\t\t\tnucleotide = sequencePattern[j-1];\n\n\t\t\tswitch(nucleotide){\n\t\t\t\tcase 'A': x = 0; break;\n\t\t\t\tcase 'a': x = 0; break;\n                case 'T': x = 1; break;\n                case 't': x = 1; break;\n                case 'C': x = 2; break;\n                case 'c': x = 2; break;\n                case 'G': x = 3; break;\n                case 'g': x = 3; break;\n\t\t\t}\n\n\t\t\t//Get the nucleotide of the subject\n\t\t\tnucleotide = sequenceSubject[i-1];\n\n\t\t\tswitch(nucleotide){\n\t\t\t\tcase 'A': y = 0; break;\n\t\t\t\tcase 'a': y = 0; break;\n\t\t\t\tcase 'T': y = 1; break;\n\t\t\t\tcase 't': y = 1; break;\n\t\t\t\tcase 'C': y = 2; break;\n\t\t\t\tcase 'c': y = 2; break;\n\t\t\t\tcase 'G': y = 3; break;\n\t\t\t\tcase 'g': y = 3; break;\n\t\t\t}\n\n\t\t\t//Find the scores in the vertical and horizontal matrices for i,j\n\t\t\t//Finding for the horizontal\n\t\t\tnewGap = grid[i][j-1] - (gapOpening + gapExtension);\n\t\t\textendGap = horizontal[i][j-1] - gapExtension;\n\t\t\t\n\t\t\thorizontal[i][j] = maxHorizontal(newGap,extendGap,direction);\n\t\t\ttracebackHorizontal[i][j] = direction;\n\n\t\t\t//Finding for the vertical\n\t\t\tnewGap = grid[i-1][j] - (gapOpening + gapExtension);\n\t\t\textendGap = vertical[i-1][j] - gapExtension;\n\t\t\t\n\t\t\tvertical[i][j] = maxVertical(newGap,extendGap,direction);\n\t\t\ttracebackVertical[i][j] = direction;\n\t\t\t\n\t\t\t//Find the score from the three directions\n\t\t\tup       = horizontal[i-1][j-1];\n\t\t\tdiagonal = grid[i-1][j-1];\n\t\t\tleft     = vertical[i-1][j-1];\n\n\t\t\t//Get the biggest one and write it into the grid\n            grid[i][j] = max3D(diagonal,up,left,direction) + scoreMatrix[x][y];\n            \n\t\t\t//Write the direction into the traceback matrix\n            tracebackGrid[i][j] = direction;\n\t\t}\n\t}\n\n    //Now, lets go backwards and write the alignment result\n\n    /*\n\t\tIn here we can actually find out the insertions and deletions.\n\t\tEvery time we come back from the vertical we have a deletion (pattern\n\t\trespect\tthe subject), and everytime we combe back from the horizontal\n\t\twe have an insertion (pattern respect the subject).\n    */\n    i--;\n    j--;\n\tdirection = 'x';\n\tmaxScore = grid[i][j];\n\n\t/*\n\t\tFor the gap ending penalty:\n\n\t\tEXPERIMENTAL\n\n\t\tIf we DO HAVE ending penalty we don't need to touch anything.\n\n\t\tOtherwise, what we do is to find the maximum score in the last column\n\t\txor row, depending of if the bigger sequence is the pattern or the\n\t\tsubject. Once we find the maximum we adjust the i xor j index so we\n\t\tstart tracebacking from there. Also adjust the result string accordingly\n\t*/\n\tif(gapEnding == false){\n\n\t\tif(DEBUG == true){\n\n\t\t\tcout<<\"Enter gap ending\" << endl;\n\t\t\tcout<<\"I: \"<< i << endl;\n\t\t\tcout<<\"J: \"<< j << endl;\n\n\t\t}\n\n\t\t//Find out the maximum score in the last row and the last column\n\t\t//The maximum score is right now set to the right-bottom corner\n\n\t\t//Get the maximum of the right column\n\t\tint maximumColumn = maxRow(grid,j,i,maximumIndex,0);\n\t\tunsigned int rowIndex = maximumIndex;\n\t\t\n\t\t//Get the maximum of the bottom row\n\t\tint maximumRow = maxColumn(grid,i,j,maximumIndex,0);\n\t\tunsigned int columnIndex = maximumIndex;\n\n\t\t//One of those three is the maximum.\n\t\t//If the max Score is the bigger, do nothing, otherwise\n\t\tif(maxScore < maximumColumn || maxScore < maximumRow){\n\n\t\t\tif(maximumColumn>=maximumRow){\n\n\t\t\t\t//Adjust the alignments and the traceback start\n\t\t\t\twhile(i!=rowIndex){\n\t\t\t\t\t\n\t\t\t\t\tpatternResult += '-'; \n\t\t\t\t\tsubjectResult += sequenceSubject[i-1];\n\t\t\t\t\tmarkup += ' ';  \n\t\t\t\t\ti--;\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse{\n\n\t\t\t\t//Adjust the alignments and the traceback start\n\t\t\t\twhile(j!=columnIndex){\n\t\t\t\t\t\n\t\t\t\t\tpatternResult += sequencePattern[j-1]; \n\t\t\t\t\tsubjectResult += '-';\n\t\t\t\t\tmarkup += ' ';  \n\t\t\t\t\tj--;\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\n\t\tif(DEBUG == true){\n\n\t\t\tcout<<\"Final START after gap ending\" << endl;\n\t\t\tcout<<\"I: \"<< i << endl;\n\t\t\tcout<<\"J: \"<< j << endl;\n\n\t\t}\n\n\t\t\n\n\n\t\n\t}\n\n\tif(DEBUG==true){\n\n\t\tcout<<\"DEBUG Align\"<<endl;\n\t\tcout<<\"Start traceback in: \"<<maximumIndex<<endl;\n\t\tcout<<\"Maximum score found: \"<<maxScore<<endl;\n\t\tcout<<\"Grid matrix\"<<endl;\n\t\tprintMatrix(grid, sequencePattern, sequenceSubject);\n\t\tcout<<endl;\n\t\tcout<<\"Horizontal matrix\"<<endl; \n\t\tprintMatrix(horizontal, sequencePattern, sequenceSubject);\n\t\tcout<<endl;\n\t\tcout<<\"Vertical matrix\"<<endl;\n\t\tprintMatrix(vertical, sequencePattern, sequenceSubject);\n\t\tcout<<endl;\n\t\tcout<<\"Traceback Grid matrix\"<<endl;\n\t\tprintMatrix(tracebackGrid, sequencePattern, sequenceSubject);\n\t\tcout<<endl;\n\t\tcout<<\"Traceback Horizontal matrix\"<<endl; \n\t\tprintMatrix(tracebackHorizontal, sequencePattern, sequenceSubject);\n\t\tcout<<endl;\n\t\tcout<<\"Traceback Vertical matrix\"<<endl;\n\t\tprintMatrix(tracebackVertical, sequencePattern, sequenceSubject);\n\t\tcout<<endl;\n\t\tcout<<\"I: \"<<i<<endl;\n\t\tcout<<\"J: \"<<j<<endl;\n\t\tcout<<\"END DEBUG Align\"<<endl<<endl;\n\t\tcout<<\"Making the traceback\"<<endl;\n\t}\n\n\twhile(i>0 || j>0){\n\n\t\tif(DEBUG == true && true){\n\n\t\t\tcout<<\"Switching...\"<<endl;\n\t\t\tcout<<\"Candidate: \"<<tracebackGrid[i][j]<<endl;\n\t\t\tcout<<\"I: \"<<i<<endl;\n\t\t\tcout<<\"J: \"<<j<<endl;\n\t\t\tcout<<\"Current Pattern\"<<endl;\n\t\t\tcout<<patternResult<<endl;\n\t\t\tcout<<markup<<endl;\n\t\t\tcout<<subjectResult<<endl;\n\n\t\t}\n\t\t\n\t\tswitch(tracebackGrid[i][j]){\n\n\t\t\t//The easiest case, just go on diagonal.\n\t\t\tcase '\\\\':\n\t\t\t\tpatternResult += sequencePattern[j-1]; \n                subjectResult += sequenceSubject[i-1];\n\t\t\t\tif(toupper(sequencePattern[j-1]) == toupper(sequenceSubject[i-1])){\n\t\t\t\t\tmarkup += '|';\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmarkup += '.';\n\t\t\t\t}\n\n\t\t\t\tif(DEBUG == true && true){\n\n\t\t\t\t\tcout<<\"Case Diagonal found\"<<endl;\n\t\t\t\t\tcout<<patternResult<<endl;\n\t\t\t\t\tcout<<markup<<endl;\n\t\t\t\t\tcout<<subjectResult<<endl;\n\t\t\t\t\tcin.ignore().get();\n\n\t\t\t\t}\n\t\t\t\t\n                i--;\n                j--;\n                break;\n\n\t\t\t//If the traceback tell us to go vertical\n\t\t\tcase 'V':\n\n\t\t\t\t/*\n\t\t\t\t If the traceback tell us to go vertical it means that the\n\t\t\t\t score came back from the DIAGONAL of the horizontal matrix\n\n\t\t\t\t So we need to mark one last pair, then follow the vertical\n\t\t\t\t path until it tell us to come back to grid.\n\t\t\t\t*/\n\t\t\t\t\t\t\t\t\n\t\t\t\t//First, lets mark the alignment with the insertion\n\t\t\t\tpatternResult += sequencePattern[j-1]; \n                subjectResult += sequenceSubject[i-1];\n                if(toupper(sequencePattern[j-1]) == toupper(sequenceSubject[i-1])){\n\t\t\t\t\tmarkup += '|';\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmarkup += '.';\n\t\t\t\t}\n\n\t\t\t\tif(DEBUG == true && false){\n\n\t\t\t\t\tcout<<\"Case Horizontal found\"<<endl;\n\t\t\t\t\tcout<<patternResult<<endl;\n\t\t\t\t\tcout<<markup<<endl;\n\t\t\t\t\tcout<<subjectResult<<endl;\n\n\t\t\t\t}\n\n\t\t\t\t\n                //indelEnd = i;\n                i--;\n                j--;\n\n\n\n\n                /*\n                \n\t\t\t\tNow we need to continue UP in the VERTICAL TRACEBACK MATRIX\n\t\t\t\tuntil we find the reference that transport us back to the\n\t\t\t\tTRACEBACK GRID.\n\n\t\t\t\t*/\n                direction = tracebackVertical[i][j];\n                \n\t\t\t\twhile(i>0 && direction!='G'){\n\t\t\t\t\tsubjectResult += sequenceSubject[i-1]; \n\t\t\t\t\tpatternResult += '-';\n\t\t\t\t\tmarkup += ' ';  \n\t\t\t\t\ti--;\n\t\t\t\t\tdirection = tracebackVertical[i][j];\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t\tSince we are going back to grid, it means that the cell to\n\t\t\t\t\twhere we are going back, was one cell TO THE LEFT from the\n\t\t\t\t\tcurrent G marker. We need to adjust and go one more step\n\t\t\t\t\tto the LEFT\n\t\t\t\t*/\n\n\t\t\t\tsubjectResult += sequenceSubject[i-1]; \n\t\t\t\tpatternResult += '-';\n\t\t\t\tmarkup += ' ';  \n\t\t\t\ti--;\n\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t//If the traceback tell us to go horizontal\n\t\t\tcase 'H':\n\n\t\t\t\t/*\n\t\t\t\t If the traceback tell us to go horizontal it means that the\n\t\t\t\t score came back from the DIAGONAL of the horizontal matrix\n\n\t\t\t\t So we need to mark one last pair, then follow the horizontal\n\t\t\t\t path until it tell us to come back to grid.\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\t//First, lets mark the alignment with the insertion\n\t\t\t\tpatternResult += sequencePattern[j-1]; \n                subjectResult += sequenceSubject[i-1];\n                if(toupper(sequencePattern[j-1]) == toupper(sequenceSubject[i-1])){\n\t\t\t\t\tmarkup += '|';\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmarkup += '.';\n\t\t\t\t}\n\n\t\t\t\tif(DEBUG == true && false){\n\n\t\t\t\t\tcout<<\"Case Horizontal found\"<<endl;\n\t\t\t\t\tcout<<patternResult<<endl;\n\t\t\t\t\tcout<<markup<<endl;\n\t\t\t\t\tcout<<subjectResult<<endl;\n\n\t\t\t\t}\n\n\t\t\t\t\n                //indelEnd = j;\n                i--;\n                j--;\n\n                /*\n                \n\t\t\t\tNow we need to continue LEFT in the HORIZONTAL TRACEBACK MATRIX\n\t\t\t\tuntil we find the reference that transport us back to the\n\t\t\t\tTRACEBACK GRID.\n\n\t\t\t\t*/\n                direction = tracebackHorizontal[i][j];\n                \n\t\t\t\twhile(j>0 && direction!='G'){\n\t\t\t\t\tpatternResult += sequencePattern[j-1]; \n\t\t\t\t\tsubjectResult += '-';\n\t\t\t\t\tmarkup += ' ';  \n\t\t\t\t\tj--;\n\t\t\t\t\tdirection = tracebackHorizontal[i][j];\n\n\t\t\t\t\tif(DEBUG == true && false){\n\n\t\t\t\t\t\tcout<<\"Case Horizontal follow\"<<endl;\n\t\t\t\t\t\tcout<<patternResult<<endl;\n\t\t\t\t\t\tcout<<markup<<endl;\n\t\t\t\t\t\tcout<<subjectResult<<endl;\n\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t\tSince we are going back to grid, it means that the cell to\n\t\t\t\t\twhere we are going back, was one cell TO THE LEFT from the\n\t\t\t\t\tcurrent G marker. We need to adjust and go one more step\n\t\t\t\t\tto the LEFT\n\t\t\t\t*/\n\n\t\t\t\tpatternResult += sequencePattern[j-1]; \n\t\t\t\tsubjectResult += '-';\n\t\t\t\tmarkup += ' ';  \n\t\t\t\tj--;\n\n\t\t\t\tbreak;\n\n\n\t\t\t//If we reach the top of the traceback grid (NOT THE HORIZONTAL!)\n\t\t\tcase '-':\n\n\t\t\t\twhile(j>0){\n\t\t\t\t\tpatternResult += sequencePattern[j-1]; \n\t\t\t\t\tsubjectResult += '-';\n\t\t\t\t\tmarkup += ' ';  \n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tbreak;\n\n\t\t\t//If we reach the left of the traceback grid (NOT THE VERTICAL!)\n\t\t\tcase '|':\n\n\t\t\t\twhile(i>0){\n\t\t\t\t\tsubjectResult += sequenceSubject[i-1]; \n\t\t\t\t\tpatternResult += '-';\n\t\t\t\t\tmarkup += ' ';  \n\t\t\t\t\ti--;\n\t\t\t\t}\n\n\t\t\t\tbreak;\t\t\t\t\n\n\t\t}\n\t\t\n\t}\n\n\t//The final result is the traceback path, but reversed\n\treverse(patternResult.begin(), patternResult.end());\n\treverse(markup.begin(), markup.end());\n\treverse(subjectResult.begin(), subjectResult.end());\n\n\t//Find the insertions and deletions once the traceback is finish.\n\t/*\n\t\tI was trying to find the indels as the tracebacks. You can find\n\t\tthe length of the indel. And you can find the position from the\n\t\trear end. But since you don't know the length of the alignment\n\t\tuntil the traceback is finish, you can't do 1-n to find the inverse\n\t\toffset as you go.\n\t*/\n\n\t//Find the insertions (look in subject)\n\tgapFound = false;\n\tindelStart = 0;\n\tindelEnd = 0;\n\tindelPatternStart = 0;\n\tindelPatternEnd = 0;\n\tpatternIndex = 0;\n\tfor(i=0; i<subjectResult.size(); i++){\n\n\t\tcurrentNucleotide = subjectResult[i];\n\n\t\tif(patternResult[i] != '-'){\n\n\t\t\tpatternIndex = patternIndex + 1;\n\t\t\t\n\t\t}\n\n\t\t//We found the beggining of a new gap\n\t\tif(gapFound == false && currentNucleotide == '-'){\n\n\t\t\tindelStart = i+1;\n\t\t\tgapFound = true;\n\t\t\tindelPatternStart = patternIndex;\n\n\n\t\t}\n\t\telse{\n\t\t\t//We found the end of the current gap\n\t\t\tif(gapFound == true && currentNucleotide != '-'){\n\n\t\t\t\tgapFound = false;\n\n\t\t\t\t//Check that we didn't found the first gap in case of an alignment\n\t\t\t\t//starting with a gap (ie: ----AA CCCCAA, no indel in there)\n\t\t\t\tif(indelStart != 1){\n\n\t\t\t\t\tindelEnd = i;\n\t\t\t\t\tindelPatternEnd = patternIndex-1;\n\n\t\t\t\t\tIndel_Info newInsertion(indelStart,indelEnd,false);\n\t\t\t\t\tIndel_Info newInsertionPattern(indelPatternStart,\n\t\t\t\t\t\t\t\t\t\t\t\t   indelPatternEnd,false);\n\t\t\t\t\t\t\t\t\t\t\t\t   \n\t\t\t\t\tinsertions.push_back(newInsertion);\n\t\t\t\t\tinsertionsPattern.push_back(newInsertionPattern);\n\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//If we count the far right/left indels,we need to close the right insertion\n\t//if there is one and the pattern alignment ends in gaps.\n\tif(farIndels==true && gapFound==true){\n\t\tindelEnd = subjectResult.size();\n\t\tindelPatternEnd = patternIndex;\n\n\t\tIndel_Info newInsertion(indelStart,indelEnd,true);\n\t\tIndel_Info newInsertionPattern(indelPatternStart,indelPatternEnd,true);\n\t\t\n\t\tinsertions.push_back(newInsertion);\n\t\tinsertionsPattern.push_back(newInsertionPattern);\n\t}\t\n\n\t//Find the deletions (look in pattern)\n\tgapFound = false;\n\tindelStart = 0;\n\tindelEnd = 0;\n\tindelSubjectStart = 0;\n\tindelSubjectEnd = 0;\n\tsubjectIndex = 0;\n\tfor(i=0; i<patternResult.size(); i++){\n\n\t\tcurrentNucleotide = patternResult[i];\n\n\t\t/*\n\n\t\t For the subject reference\n\t\t Forward the index of the subject if it is not a gap\n\t\t For example:\n\t\t\t 01234567890123456789012345678\n\t\t     aaaaaacccctt-------ttcccaaaaa\n\t\t     012345678901       2345678901\n\n\t\t\t The first 'T' has index 10 in both the alignment and the subject.\n\n\t\t\t The third 'T' has index 12 in the subject, but 19 in the alignment.\n\n\t\t  So we only count +1 if we don't have a gap.\n\t\t\t\n\t\t*/\n\t\tif(subjectResult[i] != '-'){\n\n\t\t\tsubjectIndex = subjectIndex + 1;\n\t\t\t\n\t\t}\n\n\t\t//We found the beggining of a new gap\n\t\tif(gapFound == false && currentNucleotide == '-'){\n\n\t\t\tindelStart = i+1;\n\t\t\tgapFound = true;\n\t\t\tindelSubjectStart = subjectIndex;\n\t\t}\n\t\telse{\n\t\t\t//We found the end of the current gap\n\t\t\tif(gapFound == true && currentNucleotide != '-'){\n\n\t\t\t\tgapFound = false;\n\n\t\t\t\t/*\n\n\t\t\t\t\tIf we want the start and end of the alignment to count as\n\t\t\t\t\tan indel, we need to activate 'farIndels' in this function.\n\n\t\t\t\t\tIf farIndels == FALSE\n\n\t\t\t\t\tCheck that we didn't found the first gap in case of an\n\t\t\t\t\talignment starting with a gap\n\n\t\t\t\t\t(ie: ----AA CCCCAA, no indel in there)\n\n\t\t\t\t\tIf farIndels == TRUE\n\n\t\t\t\t\t(ie: ----AA CCCCAA, valid indel)\n\t\t\t\t\t\n\t\t\t\t*/\n\t\t\t\tif(indelStart != 1 || farIndels==true){\n\n\t\t\t\t\tindelEnd = i;\n\t\t\t\t\tindelSubjectEnd = subjectIndex-1;\n\n\t\t\t\t\tIndel_Info newDeletion(indelStart,indelEnd,true);\n\t\t\t\t\tIndel_Info newDeletionSubject(indelSubjectStart,\n\t\t\t\t\t\t\t\t\t\t\t\t  indelSubjectEnd,true); \n\t\t\t\t\tdeletions.push_back(newDeletion);\n\t\t\t\t\tdeletionsSubject.push_back(newDeletionSubject);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//If we count the far right/left indels, we need to close the right deletion\n\t//if there is one and the pattern alignment ends in gaps.\n\tif(farIndels==true && gapFound==true){\n\t\tindelEnd = patternResult.size();\n\t\tindelSubjectEnd = subjectIndex;\n\n\t\tIndel_Info newDeletion(indelStart,indelEnd,true);\n\t\tIndel_Info newDeletionSubject(indelSubjectStart,indelSubjectEnd,true);\n\t\t\n\t\tdeletions.push_back(newDeletion);\n\t\tdeletionsSubject.push_back(newDeletionSubject);\n\t}\n\n\t//Find the missmatches (look in both)\n\t//We can optimize this by looking in the insertion / deletions; but for now\n\t//we are prioritazing readability\n\tsubjectIndex = 0;\n\n\tfor(i=0; i<patternResult.size(); i++){\n\n\t\t//currentNucleotide  = patternResult[i];\n\n\n\t\t//First lets check out that we are not in a gap so we can uppercase\n\t\t// By definition, there is no mutation in a gap\n\t\tif(patternResult[i] != '-' && subjectResult[i] !='-'){\n\n\t\t\tif(toupper(patternResult[i]) != toupper(subjectResult[i])){\n\n\t\t\t\tMutation_Info newMutation(i,subjectResult[i],patternResult[i]);\n\t\t\t\tmutations.push_back(newMutation);\n\n\t\t\t\tMutation_Info newMutationRelative(subjectIndex,subjectResult[i],patternResult[i]);\n\t\t\t\tmutationsRelative.push_back(newMutationRelative);\n\t\t\t\t\n\t\t\t}\n\n\t\t}\n\n\t\t/*\n\n\t\t For the subject reference\n\t\t Forward the index of the subject if it is not a gap\n\t\t For example:\n\t\t\t 01234567890123456789012345678\n\t\t     aaaaaacccctt-------ttcccaaaaa\n\t\t     012345678901       2345678901\n\n\t\t\t The first 'T' has index 10 in both the alignment and the subject.\n\n\t\t\t The third 'T' has index 12 in the subject, but 19 in the alignment.\n\n\t\t  So we only count +1 if we don't have a gap.\n\t\t\t\n\t\t*/\n\t\tif(subjectResult[i] != '-'){\n\n\t\t\tsubjectIndex = subjectIndex + 1;\n\t\t\t\n\t\t}\n\n\t}\n\n\n\t\n\n\t//Construct a new alignment object\n\tmyResult = new Alignment_Result(sequencePattern, sequenceSubject, matrix,\n\t\t\t\t\t\t\t\t\tgapOpening, gapExtension, gapEnding,\n\t\t\t\t\t\t\t\t\tpatternResult.length(), maxScore,\n\t\t\t\t\t\t\t\t\tpatternResult, markup, subjectResult,\n\t\t\t\t\t\t\t\t\tinsertions.size(), deletions.size(),\n\t\t\t\t\t\t\t\t\tmutations.size(), insertions, deletions,\n\t\t\t\t\t\t\t\t\tinsertionsPattern, deletionsSubject,\n\t\t\t\t\t\t\t\t\tmutations, mutationsRelative);\n\t\n\n\tif(DEBUG==true){\n\t\tcout<<\"Final result\"<<endl;\n\t\tcout<<patternResult<<endl;\n\t\tcout<<markup<<endl;\n\t\tcout<<subjectResult<<endl;\n\t\tcout<<\"Alignment_Result status\"<<endl;\n\t\tcout<<myResult->to_string()<<endl;\n\t}\n\n\treturn  toReturn ;\n}\n\n/**\n\tThis is the main aligning fucntion. The function allocate memory for six\n    matrices of size N+1 x M+1 , where N and M are the length of the two\n    sequences that you want to align. The function return a string\n    representation with verbose information about the alignmnent, indels and\n    missmaches, possition of those, length, etc... This information is latter\n    to be processed in R.\n\n\t@see documentation.pdf: Accompany this code there is a verbose explanation\n\t\t\t\t\t\t\ton how this algortihm works. The function runs in\n\t\t\t\t\t\t\ttime O(N²) instead of the classic O(N³) where you\n\t\t\t\t\t\t\tcheck for the whole line and column for alignment\n\t\t\t\t\t\t\textension score.\n\n    @see nwManyRCPP: This other function align X sequences one by one with a\n\t\t\t\t\t fixed subject sequence. Instead of allocating X times NxM\n\t\t\t\t\t matrices it only allocate one of max(N)xM and overwrite it\n\t\t\t\t\t as the patter sequence is swapped.\n\n\n\n    @param string sequencePattern, sequence Subject:\n\n\t\t\tThese two strings are the string representation of the sequences\n\t\t\tthat we want to align. Passed as constant references (don't\n\t\t\tduplicate and don't modify).\n    \n\n\t@param string matrix: Select a scoring matrix for the nucleotides. The\n\t\t\t\t\t\t  default matrix is NUC44. You can choose from the\n\t\t\t\t\t\t  following matrices:\n\t\t\t\t\t\t  - NUC44 (+5 for match, -4 for miss)\n\t\t\t\t\t\t  -\n\t\t\t\t\t\t  -\n\n\t@param int gapOpening, gapExtension: The score penalty for the gaps, the\n\t\t\t\t\t\t\t\t\t\t default values are 50 for opening\n\t\t\t\t\t\t\t\t\t\t and 0 for extension.\n\n\t@param bool gapEnding: Set to TRUE if you want that the score is affected by\n\t\t\t\t\t\t   the gaps at the end of the alignment. FALSE for\n\t\t\t\t\t\t   otherwise. (FALSE default)\t\t\t\t\t\t\t\t\t\t \n\n\t@param bool debug: Set to true if you want to print verbose information\n\t\t\t\t\t   about the matrices in the standard output.\n\n    @return int with 0 if everything goes according to plan.\n    \n*/\nint gotoh(const string &sequencePattern,const string &sequenceSubject,\n          const string &matrix, const int &gapOpening,\n          const int &gapExtension, const bool &gapEnding,\n          const bool &farIndels, Alignment_Result* &myResult){\n\t\n    int lengthPattern = sequencePattern.length();\n    int lengthSubject = sequenceSubject.length();\n\n    //Create the grid, vertical and horizontal matrix\n    int** grid       = new int* [lengthSubject+1];\n    int** vertical   = new int* [lengthSubject+1];\n    int** horizontal = new int* [lengthSubject+1];\n    for(int i = 0; i <= lengthSubject; i++){\n\t\tgrid[i]       = new int[lengthPattern+1];\n\t\tvertical[i]   = new int[lengthPattern+1];\n\t\thorizontal[i] = new int[lengthPattern+1];\n\t}\n\n\t//Create the traceback matrices\n    char** tracebackGrid       = new char* [lengthSubject+1];\n    char** tracebackVertical   = new char* [lengthSubject+1];\n    char** tracebackHorizontal = new char* [lengthSubject+1];\n    for(int i = 0; i <= lengthSubject; i++){\n\t\ttracebackGrid[i]       = new char[lengthPattern+1];\n\t\ttracebackVertical[i]   = new char[lengthPattern+1];\n\t\ttracebackHorizontal[i] = new char[lengthPattern+1];\n\t}\n\n\tif(DEBUG==true){\n\t\tcout<<\"Going to initialize\"<<endl;\n\n\t}\n\n    //Initialize tracebacks and score matrices\n\tinitialize(grid, vertical, horizontal, tracebackGrid, tracebackHorizontal,\n\t\t\t   tracebackVertical, sequencePattern, sequenceSubject, gapOpening,\n\t\t\t   gapExtension, gapEnding);\n\n\n\t//Show the matrices if we are debugging\n\tif(DEBUG == true){\n\t\t\n\t\tcout<<\"NW DEBUG\"<<endl;\n\t\tcout<<\"Grid matrix\"<<endl;\n\t\tprintMatrix(grid, sequencePattern, sequenceSubject);\n\t\tcout<<\"Vertical matrix\"<<endl;\n\t\tprintMatrix(vertical, sequencePattern, sequenceSubject);\n\t\tcout<<\"Horizontal matrix\"<<endl;\n\t\tprintMatrix(horizontal, sequencePattern, sequenceSubject);\n\n\t\tcout<<\"Traceback Grid matrix\"<<endl;\n\t\tprintMatrix(tracebackGrid, sequencePattern, sequenceSubject);\n\t\tcout<<\"Traceback Vertical matrix\"<<endl;\n\t\tprintMatrix(tracebackVertical, sequencePattern, sequenceSubject);\n\t\tcout<<\"Traceback Horizontal matrix\"<<endl;\n\t\tprintMatrix(tracebackHorizontal, sequencePattern, sequenceSubject);\n\t\tcout<<\"END NW DEBUG\"<<endl<<endl;\n\n\t}\n    \n    //Do the alignment\n\talign(grid, vertical, horizontal, tracebackGrid, tracebackVertical,\n\t      tracebackHorizontal, sequencePattern, sequenceSubject, matrix,\n\t\t  gapOpening, gapExtension, gapEnding, farIndels, myResult);\n\n    //Delete all the things!\n    for(int i = 0; i <= lengthSubject; i++){\n\t\tdelete[] grid[i];\n\t\tdelete[] vertical[i];\n\t\tdelete[] horizontal[i];\n\t\tdelete[] tracebackGrid[i];\n\t\tdelete[] tracebackVertical[i];\n\t\tdelete[] tracebackHorizontal[i];\n\t}\n\tdelete[] grid;\n\tdelete[] vertical;\n\tdelete[] horizontal;\n\tdelete[] tracebackGrid;\n\tdelete[] tracebackVertical;\n\tdelete[] tracebackHorizontal;\t\n\t\n    return 0;\n}\n\n\n/**\n    This is the main aligning fucntion. The function allocate memory for six\n    matrices of size N+1 x M+1 , where N and M are the length of the two\n    sequences that you want to align. The function return a string\n    representation with verbose information about the alignmnent, indels and\n    missmaches, possition of those, length, etc... This information is latter\n    to be processed in R.\n\n\t@see documentation.pdf: Accompany this code there is a verbose explanation\n\t\t\t\t\t\t\t            on how this algortihm works. The function runs in\n\t\t\t\t\t\t\t            time O(N^2) instead of the classic O(N^3) where you\n\t\t\t\t\t\t\t            check for the whole line and column for alignment\n\t\t\t\t\t\t\t            extension score.\n\n  @see nwManyRCPP: This other function align X sequences one by one with a\n\t\t\t\t\t         fixed subject sequence. Instead of allocating X times NxM\n\t\t\t\t\t         matrices it only allocate one of max(N)xM and overwrite it\n\t\t\t\t\t         as the patter sequence is swapped.\n\n\n  @param (string) sequencePattern\n\n    These two strings are the string representation of the sequences that we\n    want to align. Passed as constant references (don't duplicate and don't\n    modify).\n\n  @param (string) sequenceSubject\n\n    These two strings are the string representation of the sequences that we\n    want to align. Passed as constant references (don't duplicate and don't\n    modify).\n\n\t@param (string) matrix \n  \n    Select a scoring matrix for the nucleotides. The default matrix is NUC44.\n    You can choose from the following matrices:\n    - NUC44 (+5 for match, -4 for miss)\n    - (More to come)\n\n\t@param (int) gapOpening\n  \n    The score penalty for the gaps, the default values are 50.\n  \n  @param (int) gapExtension\n  \n    The score penalty for the extending the gap. Default is 0.\n\n\t@param (bool) gapEnding\n  \n     Set to TRUE if you want that the score is affected by the gaps at the end\n     of the alignment. FALSE for otherwise. (FALSE default)\n\n\t@param (bool) debug\n  \n     Set to true if you want to print verbose information about the matrices in\n     the standard output.\n\n  @return (string)\n  \n    With the following format:\n    (note: (at) stands for an at symbol. Otherwise doxygen goes crazy)\n\n\t\tSUBJECT SEQUENCE ALIGNMENT(at)PATTERN SEQUENCE ALIGNMENT\n\t\tIndels:\n\t\tStart(at)End(at)<Pattern,Subject>\n\t\tMissmatches:\n\t\tPossition(at)Subject Base(at)Pattern Base\n\n\t@todo : Fix the const and default in Rcpp (see bellow)\n    \n*/\n/*\n\nFor whatever reason CPP don't like the const and &  declaration, neither the\ndefault value call. While fixing that, use this header instead for testing\n\nMODIFIED HEADER, SO R DOESN'T WHINE ABOUT STUFF\nUSE THIS HEADER IN THE CODE THAT R WILL RUN\n\nstring gotohRCPP(string sequencePattern, string sequenceSubject,\n\t\t\t  string matrix, int gapOpening, int gapExtension,\n\t\t\t  bool gapEnding, bool farIndels){\n\nORIGINAL HEADER; THIS SHOULD BE FINAL\nUSE THIS HEADER IN THE CODE THAT GCC USUALLY RUN\n\nstring gotohRCPP(const string &sequencePattern,const string &sequenceSubject,\n\t\t\t  const string &matrix=\"NUC44\", const int &gapOpening=50,\n\t\t\t  const int &gapExtension=0, const bool &gapEnding=true,\n\t\t\t  const bool &farIndels=true){\n\nTHIS TWO HEADERS USED TO WORK WITH THIS FUNCTION. HOWEVER, NOW WE ARE REWRITING\nTHE FUNCTION IN A Rcpp WAY, WHY? I HAVE NO IDEA!! WHY IT DOESN'T WORK WITH\nSIMPLE STRINGS AND INTEGERS???\n\nstring gotohRCPP(string sequencePattern, string sequenceSubject,\n    \t  string matrix, int gapOpening, int gapExtension,\n\t\t\t  bool gapEnding, bool farIndels){\n\n*/\n\n// [[Rcpp::export]]\nstd::string gotohRCPP(std::string sequencePattern, std::string sequenceSubject,\n  \t\t  std::string matrix, int gapOpening, int gapExtension,\n\t\t\t  bool gapEnding, bool farIndels){\n\n\tint status = 0;\n\tAlignment_Result* myResult = NULL;\n\tstd::string result = \"\";\n\n\t//Call the interface function\n\tstatus = gotoh(sequencePattern, sequenceSubject, matrix, gapOpening,\n\t\t\t\t         gapExtension, gapEnding, farIndels, myResult);\n\n\t//If everything is fine return the results in a comprehensive string form\n\tif (status == 0){\n\n\t\tresult = myResult->to_string();\n\t\tresult += \"++++\\n\";\n\t\tresult += myResult->to_ggplot2_string() + \"\\n\";\n\t\tresult += \"++++\\n\";\n\t\tresult += myResult->to_subject_coordiantes_string() + \"\\n\";\n\t\tresult += \"++++\\n\";\n\t\tresult += myResult->get_pattern_alignment() + \"\\n\";\n\t\tresult += \"++++\\n\";\n\t\tresult += myResult->get_subject_alignment() + \"\\n\";\n\t\t\n\t}\n\t//Otherwise return an string error\n\telse{\n\t\tresult = \"Oh no! :-(\";\n\t}\n\n\treturn result;\n}\n",
    "created" : 1432298521417.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "1296|17|1303|1|\n1379|36|1438|1|\n1465|24|1531|1|\n1533|17|1560|1|\n1562|19|1776|1|\n1784|3|1790|3|\n1799|39|1842|1|\n1846|39|1855|1|\n1864|39|1933|1|\n1936|39|1945|1|\n1952|39|1995|1|\n2011|17|2018|1|\n",
    "hash" : "2103856171",
    "id" : "8703157E",
    "lastKnownWriteTime" : 1432303147,
    "path" : "~/Desktop/git2/AmpliCan/Rpackages/Gotoh/src/gotohRCPP.cpp",
    "project_path" : "src/gotohRCPP.cpp",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "cpp"
}